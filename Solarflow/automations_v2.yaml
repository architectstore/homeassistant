####################################################################
# SolarFlow Grid-Zero Automations (optimized)
#
# Entities expected:
# - sensor.shelly_phase_a_power (W) - grid sign: + import, - export
# - sensor.solarflow_800_pro_electric_level (%) - battery SoC 0..100
# - number.solarflow_800_pro_output_limit (W) - set SolarFlow discharge
# - number.solarflow_800_pro_input_limit (W) - set SolarFlow AC charge
#
# Helpers (input_number) expected:
# - input_number.solarflow_min_delta (W)            - minimum change before sending setpoint
# - input_number.solarflow_discharge_last (W)      - last discharge sent
# - input_number.solarflow_charge_last (W)         - last charge sent
# - input_number.solarflow_deadband (W)            - grid deadband around 0 W
# - input_number.solarflow_soc_discharge_min (%)   - min SoC for discharge
# - input_number.solarflow_soc_charge_max (%)      - max SoC for AC charge
#
# Notes:
# - Night: hard idle 23:00â€“08:00 (no charge, no discharge)
# - Day: 08:00â€“23:00 dynamic control with Â±deadband and delta hysteresis
# - SoC debounce increased to 20s to reduce noise
####################################################################

# ============================================================================
# NIGHT: Force SolarFlow idle (23:00 - 08:00)
# ============================================================================

- id: solarflow_night_idle
  alias: "SolarFlow â€“ Night Idle (23:00â€“08:00)"
  description: "Keep SolarFlow completely idle during night hours"
  mode: restart

  trigger:
    # Safety enforcement every 10 minutes while night
    - platform: time_pattern
      minutes: "/10"
      id: periodic_check

    # Ensure correct state after HA restart
    - platform: homeassistant
      event: start
      id: ha_startup

    # Immediate hard edge at 23:00
    - platform: time
      at: "23:00:00"
      id: night_start

    # Ensure immediate enforcement at night end too (handles manual edits)
    - platform: time
      at: "08:00:00"
      id: night_end_check

  condition:
    # Active only during night window (spans midnight) using OR
    - condition: or
      conditions:
        - condition: time
          after: "23:00:00"
        - condition: time
          before: "08:00:00"

  action:
    # Set both limits to zero
    - service: number.set_value
      target:
        entity_id:
          - number.solarflow_800_pro_output_limit
          - number.solarflow_800_pro_input_limit
      data:
        value: 0

    # Keep the "last" helpers in sync to avoid immediate delta-trigger on day start
    - service: input_number.set_value
      target:
        entity_id:
          - input_number.solarflow_discharge_last
          - input_number.solarflow_charge_last
      data:
        value: 0

    # Lightweight debug message (debug-level)
    - service: system_log.write
      data:
        level: debug
        logger: solarflow_grid_control
        message: "ðŸŒ™ Night idle enforced. Discharge=0W, Charge=0W. Trigger: {{ trigger.id }}"

# ============================================================================
# DAY: Grid-zero controller (08:00 - 23:00)
# ============================================================================

- id: solarflow_day_grid_zero
  alias: "SolarFlow â€“ Daytime Grid-Zero (Phase A) - Optimized"
  description: >
    Maintain grid power near zero on phase A by adjusting SolarFlow
    discharge and AC charge limits.
  mode: restart

  trigger:
    # React to grid power changes with short debounce
    - platform: state
      entity_id: sensor.shelly_phase_a_power
      for: "00:00:10"
      id: grid_change

    # React to SoC changes, use longer debounce to avoid noise
    - platform: state
      entity_id: sensor.solarflow_800_pro_electric_level
      for: "00:00:20"
      id: soc_change

    # Safety tick to catch missed events
    - platform: time_pattern
      minutes: "/3"
      id: safety_tick

    # Ensure immediate enforcement at day start
    - platform: time
      at: "08:00:00"
      id: day_start

    # Ensure correct enforcement after HA restart (only applies in day window via condition)
    - platform: homeassistant
      event: start
      id: ha_startup

  condition:
    # Active only during day window
    - condition: time
      after: "08:00:00"
      before: "23:00:00"

    # Sensors / numbers must be available
    - condition: template
      value_template: >
        {{ states('sensor.solarflow_800_pro_electric_level') not in ['unknown','unavailable'] }}

    - condition: template
      value_template: >
        {{ states('sensor.shelly_phase_a_power') not in ['unknown','unavailable'] }}

    - condition: template
      value_template: >
        {{ states('number.solarflow_800_pro_output_limit') not in ['unknown','unavailable']
           and states('number.solarflow_800_pro_input_limit') not in ['unknown','unavailable'] }}

  action:
    - variables:
        # -------------------------
        # Sensor readings & helpers
        # -------------------------
        grid: "{{ states('sensor.shelly_phase_a_power') | float(0) }}"
        soc: "{{ states('sensor.solarflow_800_pro_electric_level') | float(50) }}"
        last_discharge: "{{ states('input_number.solarflow_discharge_last') | float(0) }}"
        last_charge: "{{ states('input_number.solarflow_charge_last') | float(0) }}"

        # -------------------------
        # Tunable thresholds (now read from helpers)
        # -------------------------
        deadband: "{{ states('input_number.solarflow_deadband') | float(50) | int }}"
        soc_discharge_min: "{{ states('input_number.solarflow_soc_discharge_min') | float(25) | int }}"
        soc_charge_max: "{{ states('input_number.solarflow_soc_charge_max') | float(90) | int }}"
        max_discharge: 800   # device max discharge (W)
        max_charge: 1000     # device max AC charge (W)
        min_delta: "{{ states('input_number.solarflow_min_delta') | float(50) | int }}"
        import_cutoff: 100   # allowed import while still charging (W)

        # -------------------------
        # Target calculations
        # -------------------------
        target_discharge: >-
          {% if grid > deadband and soc > soc_discharge_min %}
          {% set p = grid - deadband %}
          {% set p = [p, max_discharge] | min %}
          {{ (p | round(0)) | int }}
          {% else %}
          0
          {% endif %}

        target_charge: >-
          {% set g = grid %}
          {% set lc = last_charge | int %}

          {# CASE 1: We are clearly exporting more than deadband â†’ (re)calculate charge #}
          {% if g < -deadband and soc < soc_charge_max %}
          {% set p = (g | abs) - deadband %}
          {% set p = [p, max_charge] | min %}
          {{ (p | round(0)) | int }}

          {# CASE 2: We were charging, grid is close to zero band â†’ keep last charge #}
          {% elif lc > 0 and soc < soc_charge_max
                 and g >= -deadband and g < import_cutoff %}
          {{ lc }}

          {# CASE 3: No reason to charge #}
          {% else %}
          0
          {% endif %}


    # -------------------------
    # Decision branches
    # -------------------------
    - choose:
        # ----------------------
        # BRANCH A: DISCHARGE ACTIVE
        # ----------------------
        - conditions:
            - condition: template
              value_template: "{{ target_discharge | int > 0 }}"
          sequence:
            - variables:
                new_dis: "{{ target_discharge | int }}"
                old_dis: "{{ last_discharge | int }}"
                delta_dis: "{{ (new_dis - old_dis) | abs }}"

            # Send discharge when delta threshold reached
            - condition: template
              value_template: "{{ delta_dis >= min_delta }}"

            # 1) Set discharge to target_discharge
            - service: number.set_value
              target:
                entity_id: number.solarflow_800_pro_output_limit
              data:
                value: "{{ new_dis }}"
              continue_on_error: false

            # 2) Ensure AC charge is off immediately (send 0 unconditionally)
            - service: number.set_value
              target:
                entity_id: number.solarflow_800_pro_input_limit
              data:
                value: 0
              continue_on_error: false

            # 3) Update helper trackers so delta logic sees current state
            - service: input_number.set_value
              target:
                entity_id: input_number.solarflow_discharge_last
              data:
                value: "{{ new_dis }}"

            - service: input_number.set_value
              target:
                entity_id: input_number.solarflow_charge_last
              data:
                value: 0

            # 4) Debug log
            - service: system_log.write
              data:
                level: debug
                logger: solarflow_grid_control
                message: >
                  "â¬‡ï¸ DISCHARGE set â†’ {{ new_dis }}W | grid={{ grid }}W soc={{ soc }}% (prev {{ old_dis }}W)"

        # ----------------------
        # BRANCH B: CHARGE ACTIVE
        # ----------------------
        - conditions:
            - condition: template
              value_template: "{{ target_charge | int > 0 }}"
          sequence:
            - variables:
                new_ch: "{{ target_charge | int }}"
                old_ch: "{{ last_charge | int }}"
                delta_ch: "{{ (new_ch - old_ch) | abs }}"

            - condition: template
              value_template: "{{ delta_ch >= min_delta }}"

            # 1) Set AC charge limit
            - service: number.set_value
              target:
                entity_id: number.solarflow_800_pro_input_limit
              data:
                value: "{{ new_ch }}"
              continue_on_error: false

            # 2) Ensure discharge is off (send 0 unconditionally)
            - service: number.set_value
              target:
                entity_id: number.solarflow_800_pro_output_limit
              data:
                value: 0
              continue_on_error: false

            # 3) Update helpers
            - service: input_number.set_value
              target:
                entity_id: input_number.solarflow_charge_last
              data:
                value: "{{ new_ch }}"

            - service: input_number.set_value
              target:
                entity_id: input_number.solarflow_discharge_last
              data:
                value: 0

            # 4) Debug log
            - service: system_log.write
              data:
                level: debug
                logger: solarflow_grid_control
                message: >
                  "â¬†ï¸ CHARGE set â†’ {{ new_ch }}W | grid={{ grid }}W soc={{ soc }}% (prev {{ old_ch }}W)"

      # ----------------------
      # DEFAULT: IDLE (both 0)
      # ----------------------
      default:
        # Only send zeros if previously not idle (avoid spam)
        - condition: template
          value_template: >
            {{ (last_discharge | int) != 0 or (last_charge | int) != 0 }}

        # Set both limits to zero
        - service: number.set_value
          target:
            entity_id:
              - number.solarflow_800_pro_output_limit
              - number.solarflow_800_pro_input_limit
          data:
            value: 0
          continue_on_error: false

        # Sync helpers
        - service: input_number.set_value
          target:
            entity_id:
              - input_number.solarflow_discharge_last
              - input_number.solarflow_charge_last
          data:
            value: 0

        - service: system_log.write
          data:
            level: debug
            logger: solarflow_grid_control
            message: >
              "â¸ï¸ IDLE: grid={{ grid }}W (deadband Â±{{ deadband }}), soc={{ soc }}%"


# ============================================================================
# OPTIONAL DEBUG: Log setpoint changes (info level)
# ============================================================================

- id: solarflow_debug_command_timing
  alias: "SolarFlow â€“ Debug Command Timing (light)"
  description: "Log when discharge/charge limits change"
  mode: parallel
  max: 5

  trigger:
    - platform: state
      entity_id:
        - number.solarflow_800_pro_output_limit
        - number.solarflow_800_pro_input_limit
      id: limit_changed

  action:
    - service: system_log.write
      data:
        level: info
        logger: solarflow_grid_control
        message: >
          "ðŸ“Š {{ trigger.to_state.name }} changed: {{ trigger.from_state.state }}W â†’ {{ trigger.to_state.state }}W (trigger={{ trigger.id }})"


- id: solarflow_night_charge
  alias: "SolarFlow â€“ Night Charge (23:00â€“08:00)"
  description: >
    Charge SolarFlow from the grid at 1000 W during night hours when SoC
    is low, with start/stop SoC thresholds.
  mode: restart

  trigger:
    # Periodic safety enforcement during night
    - platform: time_pattern
      minutes: "/10"
      id: periodic_check

    # React to SoC changes
    - platform: state
      entity_id: sensor.solarflow_800_pro_electric_level
      for: "00:00:20"
      id: soc_change

    # Hard edges at night start/end
    - platform: time
      at: "23:00:00"
      id: night_start

    - platform: time
      at: "08:00:00"
      id: night_end_check

    # Ensure correct state after HA restart
    - platform: homeassistant
      event: start
      id: ha_startup

  condition:
    # Only active during night (spans midnight)
    - condition: or
      conditions:
        - condition: time
          after: "23:00:00"
        - condition: time
          before: "08:00:00"

    # SoC sensor must be valid
    - condition: template
      value_template: >
        {{ states('sensor.solarflow_800_pro_electric_level') not in ['unknown','unavailable'] }}

    # Numbers must be valid
    - condition: template
      value_template: >
        {{ states('number.solarflow_800_pro_output_limit') not in ['unknown','unavailable']
           and states('number.solarflow_800_pro_input_limit') not in ['unknown','unavailable'] }}

  action:
    - variables:
        soc: "{{ states('sensor.solarflow_800_pro_electric_level') | float(50) }}"
        last_charge: "{{ states('input_number.solarflow_charge_last') | float(0) }}"
        # Start charging if SoC < 50 %.
        # Keep charging until 90 % once started (hysteresis via last_charge > 0).
        should_charge: >
          {{ soc < 90 and (soc < 50 or last_charge > 0) }}
        charge_power: 1000   # W

    - choose:
        # ----------------------
        # BRANCH: CHARGE ACTIVE
        # ----------------------
        - conditions:
            - condition: template
              value_template: "{{ should_charge }}"
          sequence:
            # Ensure no discharge
            - service: number.set_value
              target:
                entity_id: number.solarflow_800_pro_output_limit
              data:
                value: 0

            # Charge at 1000 W
            - service: number.set_value
              target:
                entity_id: number.solarflow_800_pro_input_limit
              data:
                value: "{{ charge_power }}"

            # Sync helpers
            - service: input_number.set_value
              target:
                entity_id: input_number.solarflow_discharge_last
              data:
                value: 0

            - service: input_number.set_value
              target:
                entity_id: input_number.solarflow_charge_last
              data:
                value: "{{ charge_power }}"

            # Log
            - service: system_log.write
              data:
                level: debug
                logger: solarflow_grid_control
                message: >
                  "ðŸŒ™ NIGHT CHARGE: {{ charge_power }}W | soc={{ soc }}% (last={{ last_charge }}W)"

      # ----------------------
      # DEFAULT: STOP CHARGING
      # ----------------------
      default:
        # Stop only if we were previously charging or discharging (avoid spam)
        - condition: template
          value_template: >
            {{ (last_charge | int) != 0 }}

        # Set both limits to zero
        - service: number.set_value
          target:
            entity_id:
              - number.solarflow_800_pro_output_limit
              - number.solarflow_800_pro_input_limit
          data:
            value: 0

        # Sync helpers
        - service: input_number.set_value
          target:
            entity_id:
              - input_number.solarflow_discharge_last
              - input_number.solarflow_charge_last
          data:
            value: 0

        - service: system_log.write
          data:
            level: debug
            logger: solarflow_grid_control
            message: >
              "ðŸ›‘ NIGHT CHARGE STOP: soc={{ soc }}% (>= 90% or not in charge window)"


- id: solarflow_night_charge_cloudy
  alias: "SolarFlow â€“ Night Charge if Tomorrow Cloudy (23:00â€“08:00)"
  description: >
    Charge SolarFlow from the grid at 1000 W during night hours when SoC
    is low, but only if tomorrow's forecast is cloudy.
  mode: restart

  trigger:
    # Periodic safety enforcement during night
    - platform: time_pattern
      minutes: "/10"
      id: periodic_check

    # React to SoC changes
    - platform: state
      entity_id: sensor.solarflow_800_pro_electric_level
      for: "00:00:20"
      id: soc_change

    # Hard edges at night start/end
    - platform: time
      at: "23:00:00"
      id: night_start

    - platform: time
      at: "08:00:00"
      id: night_end_check

    # Ensure correct state after HA restart
    - platform: homeassistant
      event: start
      id: ha_startup

  condition:
    # Only active during night (spans midnight)
    - condition: or
      conditions:
        - condition: time
          after: "23:00:00"
        - condition: time
          before: "08:00:00"

    # SoC sensor must be valid
    - condition: template
      value_template: >
        {{ states('sensor.solarflow_800_pro_electric_level') not in ['unknown','unavailable'] }}

    # Numbers must be valid
    - condition: template
      value_template: >
        {{ states('number.solarflow_800_pro_output_limit') not in ['unknown','unavailable']
           and states('number.solarflow_800_pro_input_limit') not in ['unknown','unavailable'] }}

    # Only charge if tomorrow is cloudy (daily forecast index 0)
    - condition: template
      value_template: >
        {% set fc = state_attr('weather.oeiras', 'forecast') %}
        {{ fc is not none
           and fc | length > 0
           and fc[0].condition in ['cloudy', 'partlycloudy', 'rainy', 'pouring'] }}

  action:
    - variables:
        soc: "{{ states('sensor.solarflow_800_pro_electric_level') | float(50) }}"
        last_charge: "{{ states('input_number.solarflow_charge_last') | float(0) }}"
        # Start charging if SoC < 50 %.
        # Keep charging until 90 % once started (hysteresis via last_charge > 0).
        should_charge: >
          {{ soc < 90 and (soc < 50 or last_charge > 0) }}
        charge_power: 1000   # W

    - choose:
        # ----------------------
        # BRANCH: CHARGE ACTIVE
        # ----------------------
        - conditions:
            - condition: template
              value_template: "{{ should_charge }}"
          sequence:
            # Ensure no discharge
            - service: number.set_value
              target:
                entity_id: number.solarflow_800_pro_output_limit
              data:
                value: 0

            # Charge at 1000 W
            - service: number.set_value
              target:
                entity_id: number.solarflow_800_pro_input_limit
              data:
                value: "{{ charge_power }}"

            # Sync helpers
            - service: input_number.set_value
              target:
                entity_id: input_number.solarflow_discharge_last
              data:
                value: 0

            - service: input_number.set_value
              target:
                entity_id: input_number.solarflow_charge_last
              data:
                value: "{{ charge_power }}"

            # Log
            - service: system_log.write
              data:
                level: debug
                logger: solarflow_grid_control
                message: >
                  "ðŸŒ™ NIGHT CHARGE CLOUDY: {{ charge_power }}W | soc={{ soc }}% (last={{ last_charge }}W)"

      # ----------------------
      # DEFAULT: STOP CHARGING
      # ----------------------
      default:
        # Stop only if we were previously charging (avoid spam)
        - condition: template
          value_template: >
            {{ (last_charge | int) != 0 }}

        # Set both limits to zero
        - service: number.set_value
          target:
            entity_id:
              - number.solarflow_800_pro_output_limit
              - number.solarflow_800_pro_input_limit
          data:
            value: 0

        # Sync helpers
        - service: input_number.set_value
          target:
            entity_id:
              - input_number.solarflow_discharge_last
              - input_number.solarflow_charge_last
          data:
            value: 0

        - service: system_log.write
          data:
            level: debug
            logger: solarflow_grid_control
            message: >
              "ðŸ›‘ NIGHT CHARGE CLOUDY STOP: soc={{ soc }}% (>= 90% or forecast not cloudy)"
